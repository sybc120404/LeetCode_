# 树

# 剑指 Offer 26. 树的子结构

[https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof)

- medium
- 题目

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值

- 示例

```cpp
树A：
    3
   /  \
  4    5
 / \
1   2
树B：
    4
   /
  1
输出：true
```

- 解题：
1. 判断B是否A的子结构，首先要在A中找到与B根节点值相同的节点，然后开始判断。这个过程对应函数`isSubStructure`
2. 判断是否子结构的过程对应函数`isEqual`
3. 在函数`isEqual`中，采用递归的**先序遍历DFS**：
    1. 如果`B==nullptr`，说明`B`在该路径已经匹配完，返回`true`
    2. 如果`A==nullptr`，说明该路径下匹配失败，返回`false`
    3. 如果`A->val!==B->val`，说明匹配失败，返回`false`
    4. 递归判断`isEqual(A->left,B->left)&&isEqual(A->right,B->right)`
4. 在函数`isSubStructure`中，也采用递归的**先序遍历DFS：**
    1. 如果A或B为空树，由题意，返回false
    2. true需要满足以下三个条件之一：
        1. `A`和`B`匹配
        2. `A`的左子树和`B`匹配
        3. `A`的右子树和`B`匹配
        
        后两步其实就是先序遍历
        
5. 时间复杂度为O(MN)，其中遍历`A`寻找根节点时间复杂度O(N)，匹配`B`树时间复杂度O(M)；空间复杂度O(M)，当`A`退化为链表时，递归深度最大
6. 代码：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    bool isEqual(TreeNode* A, TreeNode* B){
        if(B==nullptr)  return true; // B匹配成功
        if(A==nullptr)  return false; // 匹配失败
        if(A->val!=B->val)  return false; // 节点值不同，匹配失败
        return isEqual(A->left,B->left)&&isEqual(A->right,B->right); // 递归匹配左右子树
    }
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!A||!B)  return false; // A或B空，匹配失败
        return isEqual(A,B) || isSubStructure(A->left,B) || isSubStructure(A->right,B); //三个条件，满足一个即可
    }
};
```

# Leetcode 437. 路径总和3⃣️

- medium
- 给定一个二叉树根节点`root`和一个整数`targetSum`，求该二叉树里节点值之和等于`targetSum`的路径的数目
    
    路径不需要从根节点开始，也不需要在叶子结点结束，但是路径方向必须是向下的
    
- 示例

![截屏2021-09-28 上午7.18.54.png](%E6%A0%91%2079f7fb82bef847ebadf596ca176d5a5f/%E6%88%AA%E5%B1%8F2021-09-28_%E4%B8%8A%E5%8D%887.18.54.png)

- 解题方法一：递归
1. 比较容易想到，利用深度优先遍历，向下搜索可能的路径。由于路径不用从根节点出发，所以应该对每一个节点都进行一次递归。最后将所有节点出发的路径数求和，即可得到答案。
2. 搜索路径时需要进行DFS，根节点变动时则可以采用其他方式，这里也采用递归的DFS
3. 搜索路径的过程：调用`pathSum(root, targetSum)`，该函数返回`num`
    1. 首先，判断递归的结束条件是，当`root`为空时，该节点作为起点的路径数显然为0，因此直接返回0
    2. 判断当前`root→val`是否等于`targetSum`，若是，则`num+1`。然后我们向下搜索，依次调用`pathSum(root->left);pathSum(root->right)`
    3. 回溯到最开始的root后，对其左右节点，依次进行上述两步
4. 为提高可读性，将搜索路径和跟节点变动封装在两个函数中
5. 时间复杂度为O(N^2)，由于递归会使用函数栈，空间复杂度为O(N)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int getPathNum(TreeNode* root, int targetSum){
        if(!root) return 0;
        int num=0;
		if(root->val==targetSum) num++;
		num+=getPathNum(root->left, targetSum-root->val);
		num+=getPathNum(root->right, targetSum-root->val);
		return num;
}
public:
    int pathSum(TreeNode* root, int targetSum) {
		if(!root) return 0;
        int num=0;
		num+=getPathNum(root, targetSum); // 根节点判断
		num+=pathSum(root->left, targetSum);
		num+=pathSum(root->right, targetSum);
		return num;
    }
};
```

- 解法2：前缀和（待补充）