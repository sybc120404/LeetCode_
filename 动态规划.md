# 动态规划

# Leetcode 91. 解码方法1⃣️

[https://leetcode-cn.com/problems/decode-ways/](https://leetcode-cn.com/problems/decode-ways/)

- Medium
- 题目：

一条包含字母A～Z的消息通过映射 **A→1 B→2 ... Z→26** 进行编码。要解码已编码的消息，所有数字都必须基于以上的映射进行反向映射，例如：

"AAJF"→( 1, 1, 10, 6 )

"KJF"→( 11, 10, 6 )

现给只含有数字的字符串，进行解码，请返回解码的方法的总数

注意：06和6并不等价

- 示例：

```cpp
输入：s="12"
输出：2
解释：可以解码为“AB”(1, 2)或"L"(12)

输入：s="0"
输出：0
解释：没有字符映射到0开头的数字

输入：s="0"
输出：0
解释："06"不能映射到"F"
```

- 提示：
    - 1≤s.length≤100
    - s只包含数字，并且可能包含前导0
- 解题
1. 思路：解码的过程中，可以对单独一位数进行解码或是两位数一起进行解码，利用动态规划的思想，容易求解该问题。
2. 找到状态转移方程：设$f(i)$为数组字符串前$i$个元素的解码方法数，现考虑求解$f(i)$
    1. 如果第$i$个元素单独解码，那么当$s[i]≠0$时，有$f(i)=f(i-1)$
    2. 如果第$i$个元素和第$i-1$个元素一同解码，当第$s[i-1]≠0$且$s[i-1]*10+s[i]≤26$时，有$f(i)=f(i-2)$

    最终只需要将这两种解码方法数求和，即可得到答案

3. 边界条件：$f(0)=1$，即空字符串有一种解码方式
4. 实现细节：
    1. 分析状态转移方程可知，$f(i)$仅与$f(i-1)$和$f(i-2)$有关，因此可以采用**滚动数组**来降低空间复杂度。
    2. 2.b判断时可以采用**char**减法
    3. C++字符串下标从0开始，所以以上分析应做-1处理
5. 代码：

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int len=s.size(); // 字符串长度
        int a=0, b=1, c=0;  // a=f[i-2], b=f[i-1], c=f[i];
        for(int i=1;i<len+1;i++){
            c=0; // 每对一个新的元素分析，设置为0
            if(s[i-1]!='0'){ // 单独解码
                c+=b;
            }
            if(i>1&&s[i-2]!='0'&&((s[i-2]-'0')*10+(s[i-1]-'0'))<=26){ // 与前一个元素组合解码
                c+=a;
            }
            a=b;
            b=c; // 数组滚动
        }
        return c;
    }
};
```

1. 遍历一次数组，时间复杂度为$O(n)$；仅使用有限个额外变量，空间复杂度为$O(1)$

# Leetcode 639. 解码方法2⃣️

[https://leetcode-cn.com/problems/decode-ways-ii/](https://leetcode-cn.com/problems/decode-ways-ii/)

- hard
- 题目：在上一题的基础上，字符串增加`*` ，可以代替1～9中的一个数字。此外，为避免返回值过大，返回对1e9+7求模的结果
- 示例：

```cpp
输入：s="*"
输出：9
解释：这条消息可以表示1~9中的一个，解码为A~I中的一个

输入：s="1*"
输出：18
解释：可以表示11~19中的一个，每种都有两种解码方式，共9*2种
```

- 解题：
1. 与上一题的思路相同，采用动态规划。复杂在状态转移方程的求解
2. 状态转移方程：对于第i个元素
    1. 单独解码，需要满足该元素不为0
        1. $s[i]='*'$时，$f(i)=f(i-1)*9$
        2. $s[i]≠'*'$时，$f(i)=f(i-1)$
    2. 与前一个元素一同解码，需要满足$i>1$且$s[i-1]≠0$。分四种情况
        1. 两个均为数字，且组合的二位数小于等于26：$f(i)=f(i-2)$
        2. 个位数为数字，十位数为*：
            1. 如果个位数小于等于6，那么十位数可以选择1或者2：$f(i)=f(i-2)*2$
            2. 否则，十位数只能是1：$f(i)=f(i-2)$
        3. 个位数为*，十位数为数字
            1. 如果十位数是1，那么个位数可以选择1～9：$f(i)=f(i-2)*9$
            2. 如果十位数是2，个位数可以选择1～6：$f(i)=f(i-2)*6$
            3. 其他情况都无法解码
        4. 两位数均为*：可以有11～19，21～26共15种选择：$f(i)=f(i-2)*15$
3. 边界条件依然是$f(0)=1$
4. 实现细节：
    1. 对于每次结果，均求模
    2. 使用滚动数组降低空间复杂度
    3. 注意数组下标
5. 时间$O(n)$，空间$O(1)$
6. 代码：

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        long long mod=1000000007;
        long long a, b=1, c;  // a=f(i-2), b=f(i-1), c=f(i)
        for(int i=1;i<n+1;i++){
            // 单个字符解码
            c=0;
            if(s[i-1]!='*'&&s[i-1]!='0'){ // 为非0数字
                c=(c+b)%mod;
            }else if(s[i-1]=='*'){ // 为*，9种方案
                c=(c+b*9)%mod;
            }
            // 两个字符解码
            if(i>1&&s[i-2]!='0'){ // 当前字符串长度大于1且十位非0才能两个字符解码
                if(s[i-1]!='*'&&s[i-2]!='*'&&((s[i-2]-'0')*10+(s[i-1]-'0')<=26)){ // 均为数字
                    c=(c+a)%mod;
                }else if(s[i-1]=='*'&&s[i-2]!='*'){ // 十位为数字，个位为*
                    if(s[i-2]=='1'){    // 十位为1，九种可能
                        c=(c+a*9)%mod;
                    }else if(s[i-2]=='2'){  // 十位为2，1～6六种可能
                        c=(c+a*6)%mod;
                    }
                }else if(s[i-1]!='*'&&s[i-2]=='*'){ // 十位为*，个位为数字
                    if(s[i-1]-'0'<=6){  // 十位有1～2两种可能
                        c=(c+a*2)%mod;
                    }else{  // 十位只能是1
                        c=(c+a)%mod;
                    }
                }else if(s[i-1]=='*'&&s[i-2]=='*'){  // 均为*，增加11~19,21~26共15种（*不能代替0）
                    c=(c+a*15)%mod;
                }
            }
            a=b;
            b=c;    //滚动
        }
        return c%mod;
    }
};
```

---

---